# 技术设计

<cite>
**Referenced Files in This Document**   
- [vcpu.rs](file://src/vcpu.rs)
- [trap.rs](file://src/trap.rs)
- [trap.S](file://src/trap.S)
- [guest_mem.rs](file://src/guest_mem.rs)
- [regs.rs](file://src/regs.rs)
- [sbi_console.rs](file://src/sbi_console.rs)
- [consts.rs](file://src/consts.rs)
</cite>

## 目录
1. [上下文切换机制](#上下文切换机制)
2. [异常处理流程](#异常处理流程)
3. [内存虚拟化实现](#内存虚拟化实现)
4. [SBI调用转发机制](#sbi调用转发机制)
5. [指令解码与页错误处理](#指令解码与页错误处理)
6. [性能与安全性评估](#性能与安全性评估)

## 上下文切换机制

该模块通过内联汇编和CSR（控制状态寄存器）操作实现了高效的上下文切换。核心逻辑位于`_run_guest`函数中，该函数使用RISC-V汇编语言编写，直接操作硬件寄存器以最小化开销。

```mermaid
flowchart TD
A[开始上下文切换] --> B[保存宿主GPR]
B --> C[交换CSR: sstatus/hstatus]
C --> D[设置sepc指向客户机入口]
D --> E[配置stvec指向_guest_exit]
E --> F[保存sscratch并加载VmCpuRegisters]
F --> G[恢复客户机GPR]
G --> H[sret进入客户机模式]
H --> I[客户机执行]
I --> J[触发VM Exit]
J --> K[_guest_exit: 保存客户机GPR]
K --> L[恢复宿主CSR]
L --> M[恢复宿主GPR]
M --> N[返回宿主代码]
```

**Diagram sources**
- [trap.S](file://src/trap.S#L0-L182)

**Section sources**
- [vcpu.rs](file://src/vcpu.rs#L133-L157)
- [trap.rs](file://src/trap.rs#L0-L102)

## 异常处理流程

从trap触发到vmexit_handler响应的全过程涉及硬件、固件和软件三层协作。当客户机发生异常时，硬件首先捕获并跳转至预设的陷阱向量，随后由Rust代码进行详细解析和处理。

```mermaid
stateDiagram-v2
[*] --> GuestExecution
GuestExecution --> TrapDetected : 异常/中断发生
TrapDetected --> HardwareTrap : 硬件自动保存sepc/stval
HardwareTrap --> GuestExit : sret跳转至_guest_exit
GuestExit --> SaveGuestState : 保存客户机GPR
SaveGuestState --> RestoreHypervisor : 恢复宿主CSR和GPR
RestoreHypervisor --> CallVmexitHandler : 调用RISCVVCpu : : vmexit_handler
CallVmexitHandler --> AnalyzeScause : 分析scause确定异常类型
AnalyzeScause --> HandleSpecificTrap : 根据异常类型分发处理
HandleSpecificTrap --> SupervisorEnvCall : SBI调用
HandleSpecificTrap --> SupervisorTimer : 定时器中断
HandleSpecificTrap --> SupervisorExternal : 外部中断
HandleSpecificTrap --> LoadStorePageFault : 页错误
HandleSpecificTrap --> OtherUnhandled : 其他未处理异常
SupervisorEnvCall --> ProcessSbiCall : 处理SBI扩展
ProcessSbiCall --> ReturnToGuest : 设置返回值并继续执行
SupervisorTimer --> EnableGuestTimer : 启用客户机定时器中断
SupervisorExternal --> ReportExternalIrq : 报告外部中断向量
LoadStorePageFault --> DecodeInstruction : 解码导致页错误的指令
DecodeInstruction --> HandleMmioAccess : 处理MMIO读写请求
ReturnToGuest --> GuestExecution
ReportExternalIrq --> GuestExecution
HandleMmioAccess --> GuestExecution
OtherUnhandled --> Panic : 触发panic
```

**Diagram sources**
- [vcpu.rs](file://src/vcpu.rs#L169-L257)
- [consts.rs](file://src/consts.rs#L0-L91)

**Section sources**
- [vcpu.rs](file://src/vcpu.rs#L169-L257)

## 内存虚拟化实现

基于EPT（扩展页表）的内存虚拟化方案通过hgatp CSR实现两级地址转换。系统利用axaddrspace库管理物理内存映射，并在必要时通过禁用vsatp来直接访问客户机物理地址。

```mermaid
erDiagram
VmCpuRegisters ||--o{ GuestVirtualHsCsrs : "包含"
VmCpuRegisters ||--o{ HypervisorCpuState : "包含"
VmCpuRegisters ||--o{ GuestCpuState : "包含"
VmCpuRegisters ||--o{ VmCpuTrapState : "包含"
GuestVirtualHsCsrs }|--|| HGATP_CSR : "映射"
HGATP_CSR }|--|| EPT_ROOT : "指向"
EPT_ROOT }|--|| PhysicalMemory : "管理"
axaddrspace }|--|| GuestPhysAddr : "提供抽象"
GuestPhysAddr }|--|| PhysicalMemory : "对应"
GuestVirtAddr }|--|| GuestPhysAddr : "通过EPT转换"
RISCVVCpu }|--|| VmCpuRegisters : "拥有"
RISCVVCpu }|--|| guest_mem : "使用"
guest_mem }|--|| axaddrspace : "依赖"
class HGATP_CSR {
+mode: usize
+ppn: usize
}
class EPT_ROOT {
+pointer: HostPhysAddr
}
class PhysicalMemory {
+region: [u8]
}
class GuestPhysAddr {
+address: usize
}
class GuestVirtAddr {
+address: usize
}
```

**Diagram sources**
- [vcpu.rs](file://src/vcpu.rs#L85-L94)
- [guest_mem.rs](file://src/guest_mem.rs#L56-L80)
- [regs.rs](file://src/regs.rs#L191-L234)

**Section sources**
- [vcpu.rs](file://src/vcpu.rs#L85-L94)
- [guest_mem.rs](file://src/guest_mem.rs#L56-L80)

## SBI调用转发机制

SBI调用的转发机制区分了标准SBI扩展与自定义超调用（EID_HVC），通过分析a7寄存器中的扩展ID进行路由。标准调用被转发至RustSBI实现，而特定扩展则由hypervisor直接处理。

```mermaid
flowchart TD
Start([SBI环境调用]) --> ReadRegisters["读取a0-a7寄存器"]
ReadRegisters --> ExtractEidFid["提取extension_id(a7)和function_id(a6)"]
ExtractEidFid --> CheckLegacy["检查是否为遗留扩展\n(0x08 <= eid <= 0x0F)"]
CheckLegacy --> |是| HandleLegacy["处理LEGACY_SET_TIMER等"]
CheckLegacy --> |否| CheckHsm["检查是否为HSM扩展\n(eid == 0x48534D)"]
CheckHsm --> |是| HandleHsm["处理HART_START/STOP/SUSPEND"]
CheckHsm --> |否| CheckHvc["检查是否为自定义超调用\n(eid == EID_HVC)"]
CheckHvc --> |是| HandleHvc["返回Hypercall退出原因"]
CheckHvc --> |否| CheckDbcn["检查是否为调试控制台\n(eid == EID_DBCN)"]
CheckDbcn --> |是| HandleDbcn["处理console_write/read"]
CheckDbcn --> |否| ForwardToRustSbi["转发至RustSBI处理"]
HandleLegacy --> SetReturnValues["设置a0返回值"]
HandleHsm --> SetReturnValues
HandleHvc --> SetReturnValues
HandleDbcn --> SetReturnValues
ForwardToRustSbi --> GetRetFromRustSbi["获取RustSBI返回结果"]
GetRetFromRustSbi --> SetReturnValues
SetReturnValues --> AdvancePc["增加sepc跳过ecall指令"]
AdvancePc --> ReturnToGuest["返回客户机继续执行"]
```

**Diagram sources**
- [vcpu.rs](file://src/vcpu.rs#L185-L257)
- [sbi_console.rs](file://src/sbi_console.rs#L0-L61)

**Section sources**
- [vcpu.rs](file://src/vcpu.rs#L185-L257)

## 指令解码与页错误处理

指令解码与页错误处理的联动逻辑允许hypervisor透明地处理客户机对MMIO区域的访问。当发生页错误时，系统会解码导致错误的指令，识别其内存操作类型，并生成相应的MMIO退出事件。

```mermaid
flowchart TD
PageFaultDetected["检测到客户机页错误"] --> LoadTrapCsrs["加载trap_csrs (htval/stval)"]
LoadTrapCsrs --> GetFaultAddress["计算故障物理地址\ngpt_page_fault_addr()"]
GetFaultAddress --> FetchInstruction["从sepc获取原始指令\nfetch_guest_instruction()"]
FetchInstruction --> DecodeInstruction["使用riscv_decode库解码"]
DecodeInstruction --> IsLoadStore["是否为load/store指令?"]
IsLoadStore --> |否| NestedPageFault["返回嵌套页错误"]
IsLoadStore --> |是| ClassifyOperation["分类具体操作类型\n(Lb/Lh/Lw/Ld/Sb/Sh/Sw/Sd)"]
ClassifyOperation --> DetermineWidth["确定访问宽度\n(Byte/Word/Dword/Qword)"]
DetermineWidth --> IsLoad["是否为加载操作?"]
IsLoad --> |是| ExtractReadInfo["提取目标寄存器(rd)和符号扩展信息"]
IsLoad --> |否| ExtractWriteInfo["提取源寄存器(rs2)和数据值"]
ExtractReadInfo --> GenerateMmioRead["生成MmioRead退出原因"]
ExtractWriteInfo --> ReadSourceReg["从客户机寄存器读取数据"]
ReadSourceReg --> GenerateMmioWrite["生成MmioWrite退出原因"]
GenerateMmioRead --> AdvancePc["增加sepc跳过故障指令"]
GenerateMmioWrite --> AdvancePc
AdvancePc --> ReturnExitReason["返回AxVCpuExitReason"]
```

**Diagram sources**
- [vcpu.rs](file://src/vcpu.rs#L259-L358)
- [guest_mem.rs](file://src/guest_mem.rs#L77-L80)
- [regs.rs](file://src/regs.rs#L219-L234)

**Section sources**
- [vcpu.rs](file://src/vcpu.rs#L259-L358)

## 性能与安全性评估

### 性能特征
- **上下文切换开销**: 由于采用纯汇编实现且仅保存必要寄存器，上下文切换非常高效。
- **内存访问延迟**: 使用EPT实现的二级地址转换带来轻微性能损耗，但避免了影子页表的复杂同步。
- **SBI调用路径**: 大部分标准SBI调用直接转发，保持较低延迟；自定义扩展通过退出机制处理，引入额外开销。

### 安全性考量
- **内存隔离**: 通过EPT严格限制客户机只能访问分配给它的物理内存区域。
- **权限控制**: 利用RISC-V特权级机制，确保客户机运行在VS模式，无法直接访问硬件资源。
- **攻击面最小化**: 仅暴露必要的SBI扩展接口，减少潜在的安全漏洞。

### 可扩展性限制
- **架构依赖**: 高度依赖RISC-V H扩展特性，难以移植到其他架构。
- **功能局限**: 当前主要支持基本的虚拟化功能，缺乏高级特性如设备直通、实时调度等。
- **并发模型**: 设计上假设单线程操作，多vCPU场景下的同步机制需额外考虑。

**Section sources**
- [vcpu.rs](file://src/vcpu.rs)
- [Cargo.toml](file://Cargo.toml)