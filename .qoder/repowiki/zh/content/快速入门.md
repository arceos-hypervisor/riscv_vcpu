# 快速入门

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [Cargo.toml](file://Cargo.toml)
- [rust-toolchain.toml](file://rust-toolchain.toml)
- [src/lib.rs](file://src/lib.rs)
- [src/vcpu.rs](file://src/vcpu.rs)
</cite>

## 目录
1. [环境准备](#环境准备)
2. [添加依赖](#添加依赖)
3. [集成与使用流程](#集成与使用流程)
4. [常见问题排查](#常见问题排查)

## 环境准备

在开始使用 `riscv_vcpu` 库之前，必须正确配置开发环境。该库针对 RISC-V 架构设计，并依赖特定的 Rust 工具链和目标支持。

### 配置 Rust 工具链

项目根目录下的 `rust-toolchain.toml` 文件指定了所需的工具链版本和组件。此配置确保了构建环境的一致性。

```toml
[toolchain]
channel = "nightly-2025-05-20"
components = ["rust-src", "llvm-tools", "rustfmt", "clippy"]
profile = "minimal"
targets = [
  "riscv64gc-unknown-none-elf",
]
```

该配置要求：
- 使用 **nightly-2025-05-20** 版本的 Rust 编译器。
- 安装 `rust-src` 组件以支持 `no_std` 开发。
- 安装 `riscv64gc-unknown-none-elf` 目标以进行交叉编译。

**操作步骤：**
1. 确保已安装 `rustup`。
2. 将 `rust-toolchain.toml` 文件复制到您的项目根目录。
3. 运行 `cargo build`，`rustup` 将自动下载并切换到指定的 nightly 版本和目标。

**Section sources**
- [rust-toolchain.toml](file://rust-toolchain.toml#L1-L8)

## 添加依赖

要将 `riscv_vcpu` 库集成到您的项目中，需要在 `Cargo.toml` 文件中声明其作为依赖项。

### Cargo.toml 配置

根据 `Cargo.toml` 文件中的定义，`riscv_vcpu` 的当前版本为 `0.1.2`。您可以通过以下方式将其添加到您的项目中：

```toml
[dependencies]
riscv_vcpu = "0.1"
```

此版本号 `"0.1"` 是一个通配符，它会匹配所有 `0.1.x` 版本，允许向后兼容的更新。对于生产环境，建议锁定到具体的补丁版本（如 `"0.1.2"`）以确保稳定性。

**重要提示：** `riscv_vcpu` 是一个 `no_std` 兼容的 crate，这意味着它不依赖于标准库。因此，您的项目也必须在 `#![no_std]` 模式下运行。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L45)
- [src/lib.rs](file://src/lib.rs#L1-L2)

## 集成与使用流程

本节将基于 `README.md` 中的代码示例，详细说明如何在您的代码中初始化和运行一个 RISC-V vCPU。

### 1. 检查硬件虚拟化支持

在创建任何 vCPU 实例之前，首要步骤是检查底层硬件是否支持 RISC-V 虚拟化扩展（H 扩展）。这是至关重要的，因为尝试在不支持的硬件上运行虚拟化代码会导致未定义行为或崩溃。

```rust,ignore
use riscv_vcpu::{has_hardware_support};

if has_hardware_support() {
    // 硬件支持，可以安全地继续
} else {
    // 硬件不支持，应优雅地退出或降级处理
}
```

`has_hardware_support` 函数是一个简单的包装器，用于调用 `detect::detect_h_extension`。它通过读取 CPU 的 CSR（控制和状态寄存器）来探测 H 扩展的存在。

**原理：** 在嵌入式和裸机环境中，资源有限且错误恢复困难。提前检测硬件能力可以避免在运行时发生致命错误，提高系统的健壮性。

**Section sources**
- [README.md](file://README.md#L47-L49)
- [src/lib.rs](file://src/lib.rs#L24)

### 2. 创建 vCPU 配置

`RISCVVCpuCreateConfig` 结构体用于定义新 vCPU 的初始配置。您可以选择提供自定义值，或使用默认配置。

```rust
let config = RISCVVCpuCreateConfig::default();
```

`RISCVVCpuCreateConfig` 包含以下关键参数：
- **`hart_id`**: 虚拟 CPU (vCPU) 的 ID，默认为 `0`。这对应于 RISC-V 架构中的硬件线程（Hart）。
- **`dtb_addr`**: 设备树二进制文件（Device Tree Blob）的物理地址，默认为 `0x9000_0000`。设备树描述了虚拟机的硬件布局，guest OS 启动时会读取此地址来获取信息。

这些默认值适用于大多数通用场景。如果您需要创建多核虚拟机，则需要为每个 vCPU 设置不同的 `hart_id`。

**Section sources**
- [README.md](file://README.md#L50-L52)
- [src/lib.rs](file://src/lib.rs#L35-L47)

### 3. 实例化 RISCVVCpu

使用上一步创建的配置，调用 `RISCVVCpu::new` 方法来实例化一个 vCPU 对象。

```rust
let vcpu = RISCVVCpu::new(config)?;
```

`RISCVVCpu::new` 方法执行以下初始化操作：
1.  根据 `config` 设置 guest 寄存器，特别是 `a0`（hartid）和 `a1`（dtb 地址）。
2.  初始化内部的 SBI（Supervisor Binary Interface）转发器。
3.  返回一个可管理的 `RISCVVCpu` 实例。

此方法返回 `AxResult<Self>`，表明初始化过程可能失败（例如，由于无效的配置），因此需要使用 `?` 操作符或 `match` 语句来处理潜在的错误。

**Section sources**
- [README.md](file://README.md#L54-L56)
- [src/vcpu.rs](file://src/vcpu.rs#L80-L95)

### 4. 设置入口地址并运行 vCPU

在调用 `run` 之前，通常需要设置 guest 程序的入口点。这通过 `set_entry` 方法完成。

```rust
vcpu.set_entry(entry_address)?;
vcpu.run()?;
```

- **`set_entry`**: 此方法将提供的 `GuestPhysAddr` 写入 guest 的 `sepc` (Supervisor Exception Program Counter) 寄存器。当 vCPU 第一次运行时，它将从这个地址开始执行。
- **`run`**: 这是启动 vCPU 的核心方法。它会：
    -   禁用主机的中断 (`sstatus::clear_sie`) 并启用必要的 SBI 中断。
    -   调用一个名为 `_run_guest` 的外部汇编函数，该函数直接切换到 guest 上下文并开始执行 guest 代码。
    -   当 guest 发生异常、中断或系统调用（SBI 调用）时，控制权会返回到宿主。
    -   执行 `vmexit_handler` 来处理退出原因（如 SBI 调用、页面错误等），然后决定下一步操作（如模拟 I/O 或注入中断）。

`run` 方法返回一个 `AxVCpuExitReason`，指示 vCPU 停止运行的原因，开发者可以根据这个原因做出相应的决策。

**Section sources**
- [README.md](file://README.md#L58-L59)
- [src/vcpu.rs](file://src/vcpu.rs#L115-L135)

## 常见问题排查

在集成过程中可能会遇到一些典型问题，以下是解决方案：

### 构建错误：无法找到目标

**错误信息：** `error: could not compile ... target 'riscv64gc-unknown-none-elf' not found`

**解决方案：** 确保已按照 `rust-toolchain.toml` 的要求安装了正确的目标。运行以下命令：
```bash
rustup target add riscv64gc-unknown-none-elf
```

### 运行时错误：硬件不支持

**现象：** `has_hardware_support()` 返回 `false`。

**解决方案：** `riscv_vcpu` 依赖于 RISC-V H 扩展。请确认您的目标平台（如 QEMU、FPGA 或真实硬件）支持并启用了虚拟化扩展。在 QEMU 中，您需要使用 `-machine virt,virtualization=on` 参数。

### 链接错误：缺少符号

**错误信息：** `undefined reference to '_run_guest'`

**解决方案：** `_run_guest` 是一个由宿主操作系统或 hypervisor 实现的外部汇编函数。`riscv_vcpu` 本身只提供了 vCPU 的软件模型。您需要在一个完整的系统（如 ArceOS 或 AxVisor）中使用此库，这些系统会提供 `_run_guest` 的具体实现。直接在普通应用程序中链接此库将导致链接失败。